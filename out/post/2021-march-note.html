<!DOCTYPE html><html lang="zh-TW"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><script>!function(){try {var d=document.documentElement.classList;d.remove('light','dark');var e=localStorage.getItem('theme');if(!e)return localStorage.setItem('theme','system'),d.add('system');if("system"===e){var t="(prefers-color-scheme: dark)",m=window.matchMedia(t);m.media!==t||m.matches?d.add('dark'):d.add('light')}else d.add(e)}catch(e){}}()</script><title>2021 March note | s8508235&#x27;s blog</title><meta name="description" content="webrtc/linux/network reading"/><meta property="og:type" content="website"/><meta name="og:title" property="og:title" content="2021 March note"/><meta name="og:description" property="og:description" content="webrtc/linux/network reading"/><link rel="icon" type="image/png" href="/blog/favicon.ico"/><link rel="apple-touch-icon" href="/blog/favicon.ico"/><meta name="next-head-count" content="10"/><link rel="preload" href="/blog/_next/static/css/1b78593dbcd17f10b1f7.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/1b78593dbcd17f10b1f7.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/blog/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/framework.179fbac4597b1fb44bbd.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/commons.e0876e411967fe200463.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/main-4e4bc660238025254c8b.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/_app-bb91d4491726f579e113.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/1173eff4538ab0eae4f3f506dea9a7965770ad37.5b0ceb40852c6e43c8a7.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/post/%5Bslug%5D-ad718825f1e9e8f622ec.js" as="script"/></head><body><div id="__next"><div class="w-full min-h-screen bg-gray-100 dark:bg-gray-700 dark:text-white"><div class="max-w-screen-sm px-4 py-12 mx-auto antialiased font-body"><header class="flex items-center justify-between  mb-2"><div class="max-w-md"><h1><a class="text-2xl font-black text-blue-800 no-underline font-display dark:text-blue-400" href="/blog">Minimal blog</a></h1></div></header><main><article><header class="mb-8"><h1 class="mb-2 text-5xl font-black leading-none font-display">2021 March note</h1><p class="text-sm">March 27, 2021</p></header><div class="mb-4 prose lg:prose-lg dark:prose-dark"><h2>聲明</h2><p>我想筆記摘要是作給未來的自己用的，不過如果剛好有人看到我的筆記去讀原文的話，那是再好不過。<del>有人只看筆記不看課本的嗎</del></p><p>如果有錯也歡迎糾正，謝謝指教。</p><h2>Reading</h2><ul><li><p><a href="https://dev.to/lazerwalker/why-video-chat-is-a-hard-technical-problem-43gj" target="_blank" rel="noopener noreferrer">Why video chat is a hard technical problem</a></p><ul><li>本文主要是開發 webrtc 會遇到的問題</li><li>瀏覽器支援不一</li><li>需要自己的後端並且可能需要面對過多 peer to peer 連線 ( Websocket -&gt; STUN -&gt; SFU)</li><li>應該也是因為這樣才會有第三方 SDK 在做這些事情吧</li></ul></li><li><p><a href="https://hkt999.medium.com/tls-1-3-quic-%E8%88%87-http-3-%E5%B0%8D%E6%95%88%E8%83%BD%E7%9A%84%E6%94%B9%E5%96%84-a37b2ddcfc95" target="_blank" rel="noopener noreferrer">TLS 1.3 / QUIC 與 HTTP/3 對效能的改善</a></p><ul><li>本文主要是 QUIC 介紹</li><li><a href="https://www.igvita.com/2012/07/19/latency-the-new-web-performance-bottleneck" target="_blank" rel="noopener noreferrer">latency</a> 影響</li><li>基於 UDP</li><li>TLS 1.3 的 handshake 會先 Client HELLO (CHLO) 來節省 RTT</li><li>QUIC 的 handshake 類似 TLS 1.3 ( inchoate CHLO 似乎有可能一次傳不完)</li><li>解決 TCP retransmission ambiguity problem</li><li>這個<a href="https://www.uio.no/studier/emner/matnat/ifi/INF5072/v18/2018_jan25_quic_sferlin.pdf" target="_blank" rel="noopener noreferrer">pdf</a>有詳盡的介紹</li></ul></li><li><p><a href="https://gist.github.com/CAFxX/571a1558db9a7b393579" target="_blank" rel="noopener noreferrer">Persistent &quot;pipes&quot; in Linux</a></p><ul><li>persistent pipe (<a href="https://man7.org/linux/man-pages/man2/pipe.2.html" target="_blank" rel="noopener noreferrer">pipe</a> 為 Linux 重新導向資料的方法)</li><li>hole punching 為 Linux <a href="javascript:void(0)" target="_blank" rel="noopener noreferrer">fallocate</a> 提供的特性，可以標注一個檔案哪段不要 (the logical size of the file does not change; only the physical size (the number of blocks) may change)</li><li>利用這個特性把檔案當作 queue 來使用且 lseek 可以跳過 hole</li></ul></li><li><p><a href="https://medium.com/swlh/why-kafka-is-so-fast-bde0d987cd03" target="_blank" rel="noopener noreferrer">Why kafka is so fast</a></p><ul><li>實時並不代表快，而是可預測</li><li>針對吞吐量去最佳化</li><li>log-structured -&gt; append-only log -&gt; sequential 很多系統也都採用，有興趣可參考<a href="https://www.databass.dev" target="_blank" rel="noopener noreferrer">此書</a></li><li>record batch 像 <a href="https://redis.io/topics/pipelining" target="_blank" rel="noopener noreferrer">redis pipeline</a> 一樣，遇到網路問題的話還是要為了減少 RTT 還做 batch</li><li>cheap consumers 不移除 message 而是增加 offset，並依靠之前的 sequential read</li><li>unflushed buffered writes 不會 fsync -&gt; <br/>disk-backed in-memory queue -&gt;<br/>一個 ack 的 write 並不代表 durability -&gt;<br/>用 replica 來 cover</li><li></li></ul></li><li><p>RCU</p><ul><li><a href="https://hackmd.io/@sysprog/linux-rcu" target="_blank" rel="noopener noreferrer">Linux 核心設計: RCU 同步機制</a></li><li><a href="http://lwn.net/Articles/262464/" target="_blank" rel="noopener noreferrer">What is RCU, Fundamentally?</a></li><li><a href="https://lwn.net/Articles/263130/" target="_blank" rel="noopener noreferrer">What is RCU? Part 2: Usage</a></li><li><a href="https://lwn.net/Articles/264090/" target="_blank" rel="noopener noreferrer">RCU part 3: the RCU API</a></li><li><a href="https://www.huaweicloud.com/articles/74854d8cc300d73a76b7b526044f6709.html" target="_blank" rel="noopener noreferrer">Linux中的RCU的那點事</a></li><li>one writer multiple readers. mainly require 3 mechanisms to implement it.<ol><li>Publish-Subscribe Mechanism (insertion)</li><li>Wait For Pre-Existing RCU Readers to Complete (deletion)</li><li>Maintain Multiple Versions of Recently Updated Objects (reader update)</li></ol></li><li>RCU 並不保證一定能讀到新增的節點或不讀到要被刪除的節點 (grace period)</li><li>RCU 讓 reader 不需要 lock 和不需要擔心 <a href="https://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener noreferrer">memory barrier</a> (為了 instruction pipeline 效能提昇而讓 instruction 亂序執行， memory barrier 是為了避免亂序而使用) 且有不錯的效能</li></ul></li></ul></div><hr class="mt-4"/><footer><div class="flex items-center mt-8 mb-16"><picture class="flex-shrink-0 mb-0 mr-3 rounded-full w-14 h-14"><source type="image/webp" data-srcset="/blog/_next/static/images/profile-9f01dd8fafca73bac7d478af9843a4a0.png.webp"/><source type="image/png" data-srcset="/blog/_next/static/images/profile-3b1af1481b80686659714779c6b8972a.png"/><img class="lazyload blur flex-shrink-0 mb-0 mr-3 rounded-full w-14 h-14" alt="Profile" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAICAYAAADA+m62AAAAAklEQVR4AewaftIAAAEHSURBVDXBP8qCcBzA4c/3l4qkYQWBISGuzdHQ7AnaOkC3aW1o6AKewAO4BY2BQzS0iENDlOS/enF4n0eWy+VvvV6zWq3I8xzP83g+n5xOJ6IoQkQwDAPNcRy22y2j0Yg0TbFtm858PkdE2O/3TCYT1Gw2Q0QoigJd16nrmjiOeb/fJEnCdDqlqiq0LMt4PB6Mx2N0XadpGqqqoigKDocDIsJms0EZhsH5fKYsS77fL0opwjBkMBjwb7FYoC6XC57ncTweud1uNE1Dv9+nbVtEhI7ruqjX68VutyMIAjRNwzRNOpZlUZYlHaUU2nA4JE1T7vc7vu9zvV7p9XqYpsnn88GyLLIs4w/ICWSBF26ZzgAAAABJRU5ErkJggg=="/></picture><p class="text-base leading-7">Written by <a class="font-semibold" href="https://github.com/s8508235" target="_blank" rel="noreferrer noopener">s8508235</a> <b>[ZH-TW/EN]</b><br/>Before being good at writing, I have to start writing.<!-- --> </p></div></footer></article><nav class="flex flex-wrap justify-between mb-10"><a class="text-lg font-bold" href="/blog/post/limit-program-resource">← <!-- -->使用 cgroups 來限制資源</a><a class="text-lg font-bold" href="/blog/post/2021-april-note">2021 Apirl note<!-- --> →</a></nav></main><footer class="text-lg font-light">© <!-- -->2021<!-- --> If you have any questions, please send me <a href="mailto:a8508235@gmail.com">an email</a>!</footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"title":"2021 March note","date":"March 27, 2021","description":"webrtc/linux/network reading"},"post":{"content":" \n## 聲明\n我想筆記摘要是作給未來的自己用的，不過如果剛好有人看到我的筆記去讀原文的話，那是再好不過。\u003cdel\u003e有人只看筆記不看課本的嗎\u003c/del\u003e\n\n如果有錯也歡迎糾正，謝謝指教。\n\n## Reading\n- [Why video chat is a hard technical problem](https://dev.to/lazerwalker/why-video-chat-is-a-hard-technical-problem-43gj)\n  - 本文主要是開發 webrtc 會遇到的問題\n  - 瀏覽器支援不一\n  - 需要自己的後端並且可能需要面對過多 peer to peer 連線 ( Websocket -\u003e STUN -\u003e SFU)\n  - 應該也是因為這樣才會有第三方 SDK 在做這些事情吧\n- [TLS 1.3 / QUIC 與 HTTP/3 對效能的改善](https://hkt999.medium.com/tls-1-3-quic-%E8%88%87-http-3-%E5%B0%8D%E6%95%88%E8%83%BD%E7%9A%84%E6%94%B9%E5%96%84-a37b2ddcfc95)\n  - 本文主要是 QUIC 介紹\n  - [latency](https://www.igvita.com/2012/07/19/latency-the-new-web-performance-bottleneck) 影響\n  - 基於 UDP\n  - TLS 1.3 的 handshake 會先 Client HELLO (CHLO) 來節省 RTT\n  - QUIC 的 handshake 類似 TLS 1.3 ( inchoate CHLO 似乎有可能一次傳不完)\n  - 解決 TCP retransmission ambiguity problem\n  - 這個[pdf](https://www.uio.no/studier/emner/matnat/ifi/INF5072/v18/2018_jan25_quic_sferlin.pdf)有詳盡的介紹\n\n- [Persistent \"pipes\" in Linux](https://gist.github.com/CAFxX/571a1558db9a7b393579)\n  - persistent pipe ([pipe](https://man7.org/linux/man-pages/man2/pipe.2.html) 為 Linux 重新導向資料的方法) \n  - hole punching 為 Linux [fallocate](https要://man7.org/linux/man-pages/man2/fallocate.2.html) 提供的特性，可以標注一個檔案哪段不要 (the logical size of the file does not change; only the physical size (the number of blocks) may change)\n  - 利用這個特性把檔案當作 queue 來使用且 lseek 可以跳過 hole\n\n- [Why kafka is so fast](https://medium.com/swlh/why-kafka-is-so-fast-bde0d987cd03)\n  - 實時並不代表快，而是可預測\n  - 針對吞吐量去最佳化\n  - log-structured -\u003e append-only log -\u003e sequential 很多系統也都採用，有興趣可參考[此書](https://www.databass.dev)\n  - record batch 像 [redis pipeline](https://redis.io/topics/pipelining) 一樣，遇到網路問題的話還是要為了減少 RTT 還做 batch\n  - cheap consumers 不移除 message 而是增加 offset，並依靠之前的 sequential read\n  - unflushed buffered writes 不會 fsync -\u003e \\\n  disk-backed in-memory queue -\u003e\\\n  一個 ack 的 write 並不代表 durability -\u003e\\\n  用 replica 來 cover\n  - \n- RCU\n  - [Linux 核心設計: RCU 同步機制](https://hackmd.io/@sysprog/linux-rcu)\n  - [What is RCU, Fundamentally?](http://lwn.net/Articles/262464/)\n  - [What is RCU? Part 2: Usage](https://lwn.net/Articles/263130/)\n  - [RCU part 3: the RCU API](https://lwn.net/Articles/264090/)\n  - [Linux中的RCU的那點事](https://www.huaweicloud.com/articles/74854d8cc300d73a76b7b526044f6709.html)\n  -  one writer multiple readers. mainly require 3 mechanisms to implement it.\n        1. Publish-Subscribe Mechanism (insertion)\n        1. Wait For Pre-Existing RCU Readers to Complete (deletion)\n        1. Maintain Multiple Versions of Recently Updated Objects (reader update)\n  - RCU 並不保證一定能讀到新增的節點或不讀到要被刪除的節點 (grace period)\n  - RCU 讓 reader 不需要 lock 和不需要擔心 [memory barrier](https://en.wikipedia.org/wiki/Memory_barrier) (為了 instruction pipeline 效能提昇而讓 instruction 亂序執行， memory barrier 是為了避免亂序而使用) 且有不錯的效能","excerpt":""},"previousPost":{"slug":"limit-program-resource","frontmatter":{"title":"使用 cgroups 來限制資源","date":"November 20, 2020","description":"cgroups 是 control groups，為 linux 核心的一個功能"},"excerpt":"","content":"\n來限制 memory 來簡單示範一下 cgroups\n\n### Disclaimer\n我不知道這是不是正確的作法，因為從 docker 得到了 cgroups 相關知識，用來這邊，那麼進入正文\n\n---\n### Installation\n```\napt install cgroup-tools\n```\n\nor\n``` \nyum install libcgroup\nyum install libcgroup-tools\n```\n### 建立 cgroup\n\n```cgcreate  -g subsystems:path``` \u003cdel\u003e詳情請洽 red hat 官網\u003c/del\u003e\n\n關於 subsystem 也可以去 `/sys/fs/cgroup` 下面看內建的\n\n也會看到其他教學是直接在 `/sys/fs/cgroup/` 下直接加資料夾，也會自動幫你加完相關檔案\n\n```\nsudo cgcreate -g memory:/mem_test\n```\n\n### 增加限制\n\n可以看到在新增 cgroup 後，可以發現 `/sys/fs/cgroup/memory/memory_test` 下面多了一些檔案\n\n這邊主要看 `memory.limit_in_bytes` 和 `memory.usage_in_bytes` 就好，\n\n用 \n```\ncat /sys/fs/cgroup/memory/memory_test/memory.limit_in_bytes\n``` \n或 \n```\ncgget -g memory:mem_test | grep memory.limit_in_bytes\n``` \n來查看設定，接著是用 \n```\ncgset -r memory.limit_in_bytes=100G mem_test\n``` \n\u003cdel\u003e為什麼這邊不一樣啊! \u003csmall\u003e如果沒有變的話就加上 sudo \u003c/small\u003e\u003c/del\u003e\n\n### 執行程式\n\n`cgexec -g memory:/mem_test command [argument]`\n\n例如:\n```\ncgexec -g memory:/mem_test ping 8.8.8.8\n```\n\n### 觀察\n\n可以使用以下指令來看在這個 cgroup 執行的 process\n```\nsystemd-cgls memory:/mem_test\n``` \n\n看在 cgroup 使用的 memory \u003cdel\u003e應該有更好的方法，歡迎提供\u003c/del\u003e\n\n```\nwatch -n 1 \"cgget -g memory:mem_test | grep memory.usage_in_bytes\"\n``` \n\n\n### 刪除 cgroup\n\n```\nsudo cgdelete memory:/mem_test\n```\n\n### Conclusion\n\n這樣就完成簡單的限制資源，還有其他 subsystem ( cpu, blkio, devices 等等) 可以實作，也可以互相組合，雖然是被大量應用在各種容器技術中，但也是可以簡單拿出來用用看。\u003cdel\u003e大概吧\u003c/del\u003e\n\n### Reference\n- [Red hat Resource management Chapter 2](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/ch-using_control_groups)"},"nextPost":{"slug":"2021-april-note","frontmatter":{"title":"2021 Apirl note","date":"April 15, 2021","description":"linux reading"},"excerpt":"","content":" \n\n"}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2021-march-note"},"buildId":"qEWkbGeDAJTZtT_bjjpuZ","assetPrefix":"/blog","isFallback":false,"gsp":true}</script><script nomodule="" src="/blog/_next/static/chunks/polyfills-8f31809deb7932dd0187.js"></script><script src="/blog/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/blog/_next/static/chunks/framework.179fbac4597b1fb44bbd.js" async=""></script><script src="/blog/_next/static/chunks/commons.e0876e411967fe200463.js" async=""></script><script src="/blog/_next/static/chunks/main-4e4bc660238025254c8b.js" async=""></script><script src="/blog/_next/static/chunks/pages/_app-bb91d4491726f579e113.js" async=""></script><script src="/blog/_next/static/chunks/1173eff4538ab0eae4f3f506dea9a7965770ad37.5b0ceb40852c6e43c8a7.js" async=""></script><script src="/blog/_next/static/chunks/pages/post/%5Bslug%5D-ad718825f1e9e8f622ec.js" async=""></script><script src="/blog/_next/static/qEWkbGeDAJTZtT_bjjpuZ/_buildManifest.js" async=""></script><script src="/blog/_next/static/qEWkbGeDAJTZtT_bjjpuZ/_ssgManifest.js" async=""></script></body></html>