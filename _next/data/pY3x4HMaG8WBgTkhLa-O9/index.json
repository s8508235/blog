{"pageProps":{"posts":[{"slug":"2021-march-note","frontmatter":{"title":"2021 March note","date":"March 27, 2021","description":"webrtc/linux/network reading"},"excerpt":"","content":" \n## 聲明\n我想筆記摘要是作給未來的自己用的，不過如果剛好有人看到我的筆記去讀原文的話，那是再好不過。<del>有人只看筆記不看課本的嗎</del>\n\n如果有錯也歡迎糾正，謝謝指教。\n\n## Reading\n- [Why video chat is a hard technical problem](https://dev.to/lazerwalker/why-video-chat-is-a-hard-technical-problem-43gj)\n  - 本文主要是開發 webrtc 會遇到的問題\n  - 瀏覽器支援不一\n  - 需要自己的後端並且可能需要面對過多 peer to peer 連線 ( Websocket -> STUN -> SFU)\n  - 應該也是因為這樣才會有第三方 SDK 在做這些事情吧\n- [TLS 1.3 / QUIC 與 HTTP/3 對效能的改善](https://hkt999.medium.com/tls-1-3-quic-%E8%88%87-http-3-%E5%B0%8D%E6%95%88%E8%83%BD%E7%9A%84%E6%94%B9%E5%96%84-a37b2ddcfc95)\n  - 本文主要是 QUIC 介紹\n  - [latency](https://www.igvita.com/2012/07/19/latency-the-new-web-performance-bottleneck) 影響\n  - 基於 UDP\n  - TLS 1.3 的 handshake 會先 Client HELLO (CHLO) 來節省 RTT\n  - QUIC 的 handshake 類似 TLS 1.3 ( inchoate CHLO 似乎有可能一次傳不完)\n  - 解決 TCP retransmission ambiguity problem\n  - 這個[pdf](https://www.uio.no/studier/emner/matnat/ifi/INF5072/v18/2018_jan25_quic_sferlin.pdf)有詳盡的介紹\n\n- [Persistent \"pipes\" in Linux](https://gist.github.com/CAFxX/571a1558db9a7b393579)\n  - persistent pipe ([pipe](https://man7.org/linux/man-pages/man2/pipe.2.html) 為 Linux 重新導向資料的方法) \n  - hole punching 為 Linux [fallocate](https要://man7.org/linux/man-pages/man2/fallocate.2.html) 提供的特性，可以標注一個檔案哪段不要 (the logical size of the file does not change; only the physical size (the number of blocks) may change)\n  - 利用這個特性把檔案當作 queue 來使用且 lseek 可以跳過 hole\n\n- [Why kafka is so fast](https://medium.com/swlh/why-kafka-is-so-fast-bde0d987cd03)\n  - 實時並不代表快，而是可預測\n  - 針對吞吐量去最佳化\n  - log-structured -> append-only log -> sequential 很多系統也都採用，有興趣可參考[此書](https://www.databass.dev)\n  - record batch 像 [redis pipeline](https://redis.io/topics/pipelining) 一樣，遇到網路問題的話還是要為了減少 RTT 還做 batch\n  - cheap consumers 不移除 message 而是增加 offset，並依靠之前的 sequential read\n  - unflushed buffered writes 不會 fsync -> \\\n  disk-backed in-memory queue ->\\\n  一個 ack 的 write 並不代表 durability ->\\\n  用 replica 來 cover\n  - \n- RCU\n  - [Linux 核心設計: RCU 同步機制](https://hackmd.io/@sysprog/linux-rcu)\n  - [What is RCU, Fundamentally?](http://lwn.net/Articles/262464/)\n  - [What is RCU? Part 2: Usage](https://lwn.net/Articles/263130/)\n  - [RCU part 3: the RCU API](https://lwn.net/Articles/264090/)\n  - [Linux中的RCU的那點事](https://www.huaweicloud.com/articles/74854d8cc300d73a76b7b526044f6709.html)\n  -  one writer multiple readers. mainly require 3 mechanisms to implement it.\n        1. Publish-Subscribe Mechanism (insertion)\n        1. Wait For Pre-Existing RCU Readers to Complete (deletion)\n        1. Maintain Multiple Versions of Recently Updated Objects (reader update)\n  - RCU 並不保證一定能讀到新增的節點或不讀到要被刪除的節點 (grace period)\n  - RCU 讓 reader 不需要 lock 和不需要擔心 [memory barrier](https://en.wikipedia.org/wiki/Memory_barrier) (為了 instruction pipeline 效能提昇而讓 instruction 亂序執行， memory barrier 是為了避免亂序而使用) 且有不錯的效能"},{"slug":"limit-program-resource","frontmatter":{"title":"使用 cgroups 來限制資源","date":"November 20, 2020","description":"cgroups 是 control groups，為 linux 核心的一個功能"},"excerpt":"","content":"\n來限制 memory 來簡單示範一下 cgroups\n\n### Disclaimer\n我不知道這是不是正確的作法，因為從 docker 得到了 cgroups 相關知識，用來這邊，那麼進入正文\n\n---\n### Installation\n```\napt install cgroup-tools\n```\n\nor\n``` \nyum install libcgroup\nyum install libcgroup-tools\n```\n### 建立 cgroup\n\n```cgcreate  -g subsystems:path``` <del>詳情請洽 red hat 官網</del>\n\n關於 subsystem 也可以去 `/sys/fs/cgroup` 下面看內建的\n\n也會看到其他教學是直接在 `/sys/fs/cgroup/` 下直接加資料夾，也會自動幫你加完相關檔案\n\n```\nsudo cgcreate -g memory:/mem_test\n```\n\n### 增加限制\n\n可以看到在新增 cgroup 後，可以發現 `/sys/fs/cgroup/memory/memory_test` 下面多了一些檔案\n\n這邊主要看 `memory.limit_in_bytes` 和 `memory.usage_in_bytes` 就好，\n\n用 \n```\ncat /sys/fs/cgroup/memory/memory_test/memory.limit_in_bytes\n``` \n或 \n```\ncgget -g memory:mem_test | grep memory.limit_in_bytes\n``` \n來查看設定，接著是用 \n```\ncgset -r memory.limit_in_bytes=100G mem_test\n``` \n<del>為什麼這邊不一樣啊! <small>如果沒有變的話就加上 sudo </small></del>\n\n### 執行程式\n\n`cgexec -g memory:/mem_test command [argument]`\n\n例如:\n```\ncgexec -g memory:/mem_test ping 8.8.8.8\n```\n\n### 觀察\n\n可以使用以下指令來看在這個 cgroup 執行的 process\n```\nsystemd-cgls memory:/mem_test\n``` \n\n看在 cgroup 使用的 memory <del>應該有更好的方法，歡迎提供</del>\n\n```\nwatch -n 1 \"cgget -g memory:mem_test | grep memory.usage_in_bytes\"\n``` \n\n\n### 刪除 cgroup\n\n```\nsudo cgdelete memory:/mem_test\n```\n\n### Conclusion\n\n這樣就完成簡單的限制資源，還有其他 subsystem ( cpu, blkio, devices 等等) 可以實作，也可以互相組合，雖然是被大量應用在各種容器技術中，但也是可以簡單拿出來用用看。<del>大概吧</del>\n\n### Reference\n- [Red hat Resource management Chapter 2](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/ch-using_control_groups)"}]},"__N_SSG":true}